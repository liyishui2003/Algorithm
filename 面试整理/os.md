# OS
#### 1.消息队列有了解过吗？如何保证信息不丢失？如何保证一致性？
常见的有生产消费者队列，kafka，RabbitMQ。
经常用来将耗时操作异步化，解耦生产者和消费者，通过消息队列缓冲请求避免过载。

保证不丢失：
- 生产者端:生产者发送消息后，等待消息队列的ACK确认，或者发送持久化消息。RabbitMQ都支持这两个机制。
- 消息队列端：持久化存储，如kafka的日志文件持久化机制；高可用性，kafka的副本机制。
- 消费者端：消费者处理完消息后，手动发ACK确认，通过唯一ID实现幂等性处理。

保持一致性：
- 本地事务表
- kafka的事务机制
- 重试机制
- 回滚机制

#### 2.fork()的具体过程？
1.复制父进程
当调用 fork() 时，操作系统会复制父进程的地址空间（包括代码段、数据段、堆、栈等）到子进程。
子进程是父进程的完整副本，包括：
- 程序计数器（PC）：子进程从 fork() 的返回处开始执行。
- 打开的文件描述符：子进程继承父进程打开的文件描述符。
- 进程状态：包括寄存器、信号处理函数等。
2.写时复制（Copy-On-Write, COW）
现代操作系统使用写时复制技术优化 fork() 的性能。
在 fork() 调用时，子进程与父进程共享相同的物理内存页，而不是立即复制内存。
当父进程或子进程尝试修改内存页时，操作系统才会复制该内存页，确保父进程和子进程的内存独立性。
3.并发执行
fork() 调用后，父进程和子进程并发执行，执行顺序由操作系统调度器决定。

#### 3.fork()都会返回吗？
返回结果：
在父进程中，fork() 返回子进程的 PID。
在子进程中，fork() 返回 0。
如果 fork() 失败，返回 -1，并设置 errno 表示错误原因。

#### 4.linux命令行输入命令后的执行过程？
- shell解析用户输入的命令
- 查找可执行文件
- 调用fork()创建子进程
- 调用exec()系列函数执行命令，加载可执行文件
- 操作系统加载可执行文件到内存，解析可执行文件的格式，加载代码段数据段等
- 移交CPU控制权给可执行程序，执行完毕后将结果输出到标准输出(通常是终端)
- 它们在做这些时，shell调用wait()，等待子进程执行完毕
- 子进程退出后，回收进程描述符和内存和退出状态
  
#### 5.CAS操作了解吗？
原子操作，本质上是硬件支持的原子指令。
CAS 操作比较内存中的值与期望值，如果相等，则将内存中的值更新为新值；否则，不做任何操作。
这些步骤都是原子的，操作过程中不会被其它线程打断。

经常用于原子加减/无锁队列/线程安全的计数器。

优点：避免了锁的开销，性能更好，但编码更复杂。
缺点：ABA问题，即内存中的值从A变成B又变成A，CAS无法检测到这种变化；忙等待，CAS操作会多次尝试。

解决ABA：增加版本号

#### 6.int和uint和浮点数的二进制表示，每一位的含义？
int:	补码表示，最高位为符号位，其余位表示数值大小。
uint:	无符号二进制表示，所有位表示数值大小。
浮点数:	IEEE 754 标准表示，分为符号位、指数位和尾数位。

#### 7.进程和线程的区别，相关系统调用
进程是正在运行的一段程序，线程是进程当中的一条执行流程。
线程最主要的特点是并发运行、共享相同的资源(代码段、数据、文件)但是各自有独立的寄存器和栈。
比如有份代码

```cpp
main(){
  while(1){
     read();
     unZip();
     Play();
  }
}
```
单进程播放的话，只能顺序执行，这显然是不对的，音画都不连贯了，事实上可以同时做。如果简单地改成多进程，那进程间该如何通信呢？(此处不表，见下一道)

所以这就引入了线程。开3个线程read()、unZip()、Play()并放到线程池里，
就能并发执行了。
比较进程和线程：
- 线程是调度的基本单位，进程是资源拥有的基本单位
- 线程更快，因为能共享资源，不需要太多额外的信息，所以创建快、终止快、切换快(共享页表)

相关系统调用:
进程:fork(),exec(),exit(),wait(),getpid()
线程:pthread_create(),pthread_exit(),pthread_join(),pthread_mutex()

8.锁有哪些种类？互斥锁和自旋锁的区别与具体应用？能不加锁吗？
- 互斥锁（Mutex）就像房间钥匙，在任何时刻只有一个线程能够拿到这把钥匙，否则就被阻塞，直到锁被释放。这会带来线程上下文的切换。互斥锁常用于临界区较长的场景，如多线程同时读写一个文件/访问数据库/共享数据结构。

- 自旋锁（Spin Lock）自旋锁不会阻塞，而是不断检查锁是否被释放。线程不进入睡眠状态，一直占用 CPU 资源进行循环等待，所以称为 “自旋”。自然就避免了线程上下文切换的开销。自旋锁适用于锁的持有时间非常短，且线程竞争不激烈的场景，例如多个线程同时更新一个计数器(该操作通常非常快)或者内核编程中短时间同步

- 读写锁（Read-Write Lock） 允许多个读线程，写线程独占，适用于读多写少的场景。

- 条件变量（Condition Variable）条件变量通常与互斥锁配合使用，用于线程之间的通信和同步。它允许线程在满足特定条件时才进行相应的操作，否则就等待。线程可以在条件变量上等待，直到其他线程通过信号或广播的方式通知它条件已经满足，才会被唤醒继续执行。
  
- 能不加锁，但更为复杂。比如TBB和boost就提供了基于原子操作或者细粒度实现的容器。

#### 9.用户态内存分为哪些区域？
- 代码段，存储程序代码
- .data，存储已初始化的全局变量
- .bss，未初始化的全局变量
- 堆，分配动态内存
- 栈，存储局部变量和参数
- 共享库，存储动态链接库的代码和数据
- 内存映射区域，内存映射文件或匿名内存映射(mmap，比如从内存中读数据出来可以放在这里，可以开辟一块内存让进程共享)

#### 10.一段程序经历的阶段？
- 写代码
- 预处理(处理预处理指令，如include和define)
- 编译，gcc/clang将预处理后的源代码编译成汇编代码.s文件
- 汇编，将汇编代码翻译成机器代码，生成目标.o文件
- 链接，将目标文件与库文件链接，生成可执行文件，输出.exe文件
- 加载，将可执行文件加载到内存中，然后是运行和结束

#### 11.如何保证一个类是线程安全的？
- 使用mutex+条件变量保护数据，实现同步
- 使用原子操作
- 不需要改动的对象尽量用const修饰
- 无锁数据结构

#### 12.i++操作是线程安全的吗？
不是，这分为读取i，+1，写回，这三个操作之间随时可能被打断。
可以加互斥锁/自旋锁，用原子操作实现。

#### 13.生产消费者模型中锁是如何实现的？


#### 14.进程间通信方式？

这个问题很大，尽量简单讲。本来进程的用户地址空间是独立的，不能互相访问，但所有进程
都共享内核空间，所以进程之间通信必须通过内核。
- 管道(内核里面的一串缓存)。linux命令里有个"|"，意思是把前者的输出作为后者的输入，这就算单向通信。
通信的话需要有来有往，管道的设计是让一个进程同时连管道的读端和写端，这怎么通信？
A：再fork一个子进程(fork能复制上一级进程的文件描述符)，这样两个进程都接到了管道里，就可以读写同一个管道了。你也可以简单地理解为它们约好了一个神秘地点，要写东西和拿东西都来这里，所以也特别慢。

- 消息队列(保存在内核中的消息链表)。A 进程要给 B 进程发送消息，A 把数据放在对应的消息队列后就可以返回，B 进程需要的时候再去读就行。和管道不同，匿名管道随着进程创建完就销毁，消息队列会随着内核一直在。消息就像邮件，不及时、有附件限制、数据拷贝开销(因为是保存在内核中的，所以用户态内核态之间读写时，肯定有拷贝开销)。

- 共享内存。本来每个进程都有独立的虚拟空间(当然了，进程的虚拟内存会映射到不同的物理内存，才不会互相影响)，共享就是拿出一块虚拟地址映射到相同的物理内存。这样一个进程一写入，另一个马上能看，不用拷贝。具体的，可以用shmget创建共享内存。

- 信号量。既然共享，就会冲突。用信号量来实现任意时刻资源只能被一个进程访问的保护机制。信号量是一个int，有PV操作，在分类上也分为同步信号量和互斥信号量。P操作：把信号量-1，如果此时信号量<0，表示被占用；如果>=0，说明还有资源可用。V操作：把信号量+1，如果<=0，表明还有进程阻塞着，就把它叫起来；如果信号量>0，说明当前没进程阻塞了。使用时P操作在进入共享资源前，V操作在离开共享资源后，必须成对出现。接下来就互斥信号量和共享信号量举个例子：
**互斥信号量**(初始值为1)：①进程A执行P操作，执行后信号量为0，资源可用，A使用。②如果此时B想访问，也执行了P，信号量变成-1，
资源不能用，B被堵塞。③A用完后，V操作让信号量恢复为0，发现有进程阻塞，所以把B叫起来。④等B用完后，V操作又让信号量恢复到1。
**同步信号量**(初始值为0)：①B要用资源，执行完P发现信号量是-1，表示A还没产生数据，B就阻塞等待。②A产生完数据后，V操作让信号量变成0，唤起B。
所以同步信号量能保证进程A在进程B之前执行。

- socket通信。是的，不仅能在网络间通信，进程间也行。不过bind的不是IP地址和端口，而是绑定本地文件。


#### 15.进程间共享变量怎么做？
相当于进程间通信，参考上一题。

#### 16.为什么要用虚拟内存？为什么要分段和分页？段页式？
- 隔离进程
- 内存共享，方便通信
- 突破物理内存限制，通过将暂时不用的页面交换到磁盘上，2G的程序能在只有1G物理内存的系统上运行。不用将所有程序都一次性载入(单片机就是一次性烧入)也体现了很优雅的设计原则。
- 页表有读写权限、标记该页是否存在，提供更好的安全性，这是一个小小的buff

操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就。
那具体怎么映射呢？
- 内存分段。
把程序分成若干个逻辑分段(比如代码一段、数据一段、栈一段)，每段分开放。
那就得知道每段对应到哪里，我们用段表来表示这个映射。段表由段基地址+段界限组成，一个段拿着自己的段号来表里找对应的基地址，加上偏移量就能找到物理地址。比如代码段里需要访问偏移量为500的虚拟地址，在段表里找到代码段的基地址为7000，加上偏移量500=7500，7500就是物理地址了。
分段的思想很清晰，但容易有内存碎片，会产生多个不连续的小物理内存，导致新的程序无法被装载。而这些小物理内存的空间如果安排得当，又是能连在一起放更大的进程的。这样内存空间无法连续利用的碎片叫外部内存碎片。解决手段是内存交换(Linux里的swap)，先把某程序占用的内存写到硬盘上，再读回来，不过读取回来时不装到原来位置，而是紧贴着某块被占用的内存后面。这样就能保证空间尽量连续。
看起来很美好，但硬盘读写太慢了，所以分段从机制上就不行，接下来我们考虑内存分页。

- 内存分页。分页裁剪得更细致，不是按逻辑分段，而是把虚拟空间、内存空间都切成一段段固定的“页”，linux下页的大小是4KB。
这样映射时，虚拟内存的一个页对应到物理内存的一个页，页之间都是贴着的，就不会有外部碎片。但可能数据用不满4KB，所以就出现了内部碎片。要关注的另一个问题是分页时怎么地址转换的？和分段有段表一样，分页也有页表。页表存着虚拟页对应物理页的基地址，基地址加上偏移量就是真实地址。
看起来很美好，但有大问题：页表会很大很大。考虑用多级页表解决：原本32位linux下每个进程拥有4G的虚拟地址，每个虚拟地址都需要映射，页大小位4KB，所以4G一共需要$4*1024*1024/4=1048576$这么多条。页表里每个项占用4Byte，所以一个页表要占$1048576*4(Byte)=4MB$。
考虑把这100多万项再分页，分成$1024(第一级)*1024(第二级)$，可以理解为原本是一维数组，现在压缩成了二维数组，但空间不变。
理论上二级表占用的空间是4KB(一级页表)+4MB(二级页表)好像还多了一级页表的开销，但事实上有“局部性原理”，其实我们用不了那么多空间。
所以如果一级页表的某个项没被用到，就不用创建对应二级页表，这部分就节省了很多空间。
热知识：64位的系统页表是4级的。

- 段页式管理。上述两种方法各有千秋，但不是对立的，实践中经常组合起来使用。先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页。这样，地址结构就由段号、段内页号和页内位移三部分组成。当然也要建立对应的段表、页表了。


#### 17.什么是内核态，什么是用户态
内核态是CPU的一种运行模式，操作系统内核就在此模式下运行。
具有最高权限，可以执行CPU所有指令，访问所有硬件资源和系统内存，往往用在系统调用/中断处理/设备驱动。
而用户态则只能执行非特权指令，只能访问分配给它的内存和资源，往往用在用户程序/库函数。

#### 18.异常和中断的区别？
异常与程序执行相关，是程序执行时发生的错误或特殊情况(如/0，访问非法内存，缺页)，同步发生，接下来要处理程序错误或者系统调用；中断与外部事件相关，是外部设备或定时器发出的信号(如硬件中断有io输入，定时器每隔一段时间触发中断)，异步发生，接下来要处理外部事件或者时间片轮转。
