# 计网
## TCP
#### 1.TCP三次握手过程/四次挥手过程？为什么是三次，为什么是四次？多一次少一次不行吗？
参考 https://csguide.cn/network/transport/20_tcp_handshake.html
三次握手：

是因为TCP是全双工的，本来要先发一个ack表示我收到了，再发一个syn表示我也想跟你建立连接，
这样有来有往了两次后才建立起连接，然后我们发现ack和syn可以合在一起，于是四次变成了三次。

再少一次的话，没法保证连接的发起方有收到ack+syn报文，再多一次则没必要，已经能够基本保证双方在线，再多就
浪费网络资源。

四次挥手：
挥手则比较特别，涉及到close_wait和time_wait这两个要重点考虑的状态。
假设断开连接的那方为A，被断开的为B，A发fin跟B说我要跟你断了，B回了一个ack表示我知道了。
但并不会立马断开连接，而是变为 CLOSE_WAIT状态。B会通知应用层对方想要关闭连接，CLOSE_WAIT 状态将一直持续到应用层调用 close()，这期间要处理：完成剩余数据的发送/清理资源。如果应用程序有 bug 没有正确调用 close()，连接会一直停留在 CLOSE_WAIT 状态，造成资源泄漏。

等到B确定自己手上没事了，可以断开后，再发送fin给A，A收到了后发ack给B，表示自己知道你的答复了。至此，已经完成了4次，没法像刚才握手那样合并成3次是因为挥手时B的ack和syn不能合并在一起发送，所以就是本来的四次。

A端在发出ack后，进入time_wait状态，通常会持续2MSL(最大报文生存时间)，这是为了使得该连接中所有的报文都从互联网中消失，不会跟后面混淆。同时，可能这次发出的ack消失了，B端等了很久一直没收到答复，会再发一个fin，这时A就能正确处理。如果一发出去就不管，可能没法保证我的fin正确被对方收到。因此，time_wait状态既是为了给本次连接收尾，也是为了确保fin报文能顺利到达。


#### 2.syn序列号是怎么确定并发送的？
syn序列号最开始的值也称为ISN，是一个32位的随机数，随机是为了增加不可预测性防止攻击。
在接下来的连接中，syn序列号会随着数据字节的发送递增，一个字节+1。

#### 3.为什么ack回应的序列号是x+1？
1.能表达：接收方真的收到了
2.能回复：我现在需要你的第x+1号数据，发送方才能知道接收方收到了哪些，现在需要什么。

#### 4.简述DDos攻击，该如何防治？
一般是syn flood或者udp flood，在短时间内向某个服务器发送大量的请求，使得服务器处理不过来，耗尽目标资源。
防治的话考虑：
- 专业的DDos防护服务，如Cloudflare(每次登codeforces都要被这玩意卡一下，原来是在检测我的流量正不正常)。cloudflare
有一个全球分布的网络，能吸收和分散攻击流量，此外还能通过历史数据/行为分析来检测请求是否为异常并拦截。
- CDN加速，CDN加速的原理同样也是把静态页面分布在全球，请求会到离自己最近的节点加载静态资源。
- 负载均衡，将流量分散到多台服务器，避免单点过载

#### 5.RST有什么具体作用？
RST（Reset） 是 TCP 协议中的一个标志位，用于立即终止 TCP 连接。它的作用是在某些异常情况下强制关闭连接，而不是通过正常的四次挥手过程。
- 检测到异常情况（如非法连接、协议错误等），直接用RST终止
- 拒绝请求/认为连接已经失效或不再需要时，用RST

#### 6.MTU是什么？
单个数据包能携带的最大数据量，一般为1500字节左右，以太网/wifi/vpn的MTU会不同，但不会偏1500太多。

#### 7.TIME_WAIT有什么用？
见1.TCP三次握手过程/四次挥手过程？

#### 8.比较TCP和UDP
TCP面向连接，可靠，保证顺序，有流量控制和拥塞控制机制，因此效率也较慢，头部开销较大，适用于网页浏览/文件传输/电子邮件。
UDP无连接，不可靠，不保证顺序，没有流量和拥塞控制机制，因此效率也较快，头部开销较小，适用于视频流媒体/在线游戏/语音通话。

一个TCP句柄什么情况下会有可读事件？
- 接收缓冲区中有数据
- 对方关闭数据，会触发可读事件，如果读到的返回值为0，说明对方关闭连接
- 监听到新的连接也会触发可读事件
- 收到tcp错误时，也会，如果读到的返回值为01表示发生了错误。

TCP的connect发送了什么报文?
三次握手。

UDP的句柄能执行connect吗？
行为不同。UDP的connect() 并不是用于建立连接（因为 UDP 是无连接的协议），而是用于绑定默认的远程地址和端口

#### 9.TCP为什么会粘包(Nagle算法)和解决方法？
TCP粘包是因为Nagle算法。Nagle算法为了避免多次发送很小的数据包导致浪费，会把多个数据包合并成一个大数据包，导致接收方无法分辨
数据的边界。
一个流氓的解决办法是直接把Nagle算法ban了，因为它在linux里是默认开启的，可以关掉。但实践中其实是在每个数据包头部添加长度字段，接收方先读取长度字段，再根据长度读取数据。

#### 10.怎么设计一个可靠且报文有序的UDP协议？

#### 11.讲一下TCP的滑动窗口机制，滑动窗口大小如何确定？

#### 12.全连接队列与半连接队列了解吗？
收到了syn报文，发出了ack+syn，但还没等到ack确认时，这些连接先放入半连接队列。
等收到了ack确认后，再把连接从半连接队列移出，放进全连接队列。

#### 13.如果出现很多次close_wait怎么解决？close_wait和time_wait分别在哪个阶段？

#### 14.TCP建立连接个数可以超过端口号个数吗？如何确定唯一的TCP连接？
可以，因为TCP连接是由四元组确定的(源IP，源端口，目标IP，目标端口)，显然四元组的组合数目可以超过端口号个数。

#### 15.流量控制与拥塞控制区别？

#### 16.输入一个URL，计算机会发生什么？

## HTTP

#### 1.http请求由哪部分构成？
- 请求行。请求方法如get/put/delete + 请求目标如/index.html + http版本如http1.1），如
`GET /index.html HTTP/1.1`
- 请求头。包含多个键值对。如Host/User-Agent/Accept/Authorization/Cookie
- 空行\r\n。用来分割请求头和请求体
- 请求体。包含真正要发送的数据
  
#### 2.常见的请求头有什么？
- Host：表示请求的目标主机和端口，如Host: www.example.com。
- User-Agent：表示客户端的类型和版本，如User-Agent: Mozilla/5.0。
- Accept：表示客户端能够接收的响应内容类型，如Accept: text/html。
- Content-Type：表示请求体的数据类型（通常用于 POST 或 PUT 请求），如：Content-Type: application/json。
- Content-Length：表示请求体的长度（以字节为单位），如：Content-Length: 123。
- Authorization：表示客户端的身份验证信息，如：Authorization: Bearer <token>。
- Cookie：表示客户端发送的 Cookie 信息，如：Cookie: name=value。

#### 3.get和post的区别？
get通常用来获取资源，post用来提交表单。

#### 4.HTTP用TCP还是UDP？
通常是TCP，但http3引入了QUIC协议，基于UDP实现的，其在UDP基础上实现了快速连接建立和加密，减少了握手延迟。

#### 5.常见状态码
200 是成功
300 是重定向
400 是自己有问题
500 是服务器有问题

#### 6.http是长连接还是短连接，如何用UDP实现
这个得看具体情况讨论。
- http1.0默认是短连接，每次请求完成后，都会关闭TCP连接。
- 从http1.1开始，默认开启keep-alive，也就是长连接机制，可以在一次TCP连接中发送多个http请求和响应。

用UDP实现的话：
- 可靠性方面:由于 UDP 不可靠，需要在应用层实现可靠性机制，如：确认机制（ACK）：接收方收到数据后发送确认消息；重传机制：如果发送方未收到确认消息，重新发送数据；序列号：为每个数据包添加序列号，确保数据顺序。
- 长连接模拟:
在 UDP 中模拟长连接，可以通过会话标识：为每个会话分配唯一标识符，客户端和服务器根据标识符维护会话状态；心跳机制：定期发送心跳包，检测连接是否存活。

#### 7.使用HTTP从服务器获取数据，数据有长有段，如何接受？
http的请求头里有Content-Length，表示数据长度，还有Transfer-Encoding，表示分块发送。
读取这两个的值然后判断是直接根据长度去读，还是分块接受就好了。

#### 8.HTTP为什么要用非对称加密和对称加密？为什么不只用一个？
见2.HTTPS怎么保证安全通信？同时用是为了保证安全性和速度。

#### 9.知道http有几个版本吗，2和3有什么区别

## 网络安全
#### 1.对称加密与非对称加密过程？
对称加密是只有一个密钥，拿同一个密钥加密解密。
非对称加密是有一对密钥，拿公钥加密，拿私钥解密，且无法从公钥推导出私钥。

#### 2.HTTPS怎么保证安全通信？
基于TLS握手/SSL加密/数字证书。
具体的，保密层是：
- 客户端生成一个随机的对称密钥（会话密钥），用于后续的加密通信。
- 客户端使用服务器的公钥加密对称密钥，并将加密后的密钥发送给服务器。
- 服务器使用自己的私钥解密客户端发送的对称密钥。
- 客户端和服务器使用对称密钥加密和解密后续的通信数据，对称加密速度快，适合加密大量数据。


## 其它协议
#### 1.知道ICMP吗？

#### 2.7层，5层，4层协议？每层的常见协议？

#### 3.cookie和session的区别？
