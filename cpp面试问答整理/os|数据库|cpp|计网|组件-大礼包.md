# CPP
## STL
#### 1.迭代器失效问题
- 树形迭代器(map/set/multimap/multiset)的插入和修改都不影响其它迭代器，删除后被删除元素的迭代器失效
- 链表形迭代器(list)同上
- 数组形迭代器(vector/deque)，被操作元素及其后边的元素迭代器都失效(如果capcity发生改变，则全部失效，这里特指vector的resize())

#### 2.vector
- 分配是在堆还是在栈？在堆。因为要求下标连续，栈内没法保证连续；其次vector需要扩展，栈内也没法扩展。
- resize和reserve有什么区别？resize用来改变实际存储的元素数量(size)，如果比原来小，会删除末尾元素，如果比原来大，会添加默认值。
而reserve改变的则是预分配内存大小(capcity)，如果比原来小，不会做任何事情，如果比原来大，会重新分配内存。
- 如何改变size大小？resize(),push_back(),pop_back(),clear(),insert(),erase()
- 如何改变capcity大小？reserve(),shrink_to_fit()

#### 3.map
- map是线程安全的吗？不是，这只是一种数据结构，设计的时候没有考虑多线程并发。要保证线程安全得加锁
- map和unordered_map的效率比较？时间上map是O(logN)，unordered_map是O(1)，最坏情况下退化成O(N)。要考虑缓存和空间的话，map的缓存连续性差，因为不连续。
- unordered_map的底层？哈希表。
- map的底层(即红黑树原理)？节点分为红色黑色，插入时大力分类讨论，通过左旋或右旋来保证树的高度维持在log。
- 讲一下开链法？线性探测/二次探测，和链地址法那样每个下标带一个链表不同，开链法在遇到哈希冲突时会探测下一个可用的桶来解决冲突。
  
#### 4.一致性哈希算法和普通哈希算法有什么区别？
普通哈希在N或者模数改变时，几乎大部分数据都要重新映射，不利于实践中服务器扩容或者处理服务器崩溃。
而一致性哈希则采用固定模数2^32-1，将哈希空间映射成一个很大的环，服务器根据编号映射到环上。查找数据时查找顺时针离自己最近的服务器，扩容时只要添加新的节点，服务器崩溃时请求也可以走向下一个服务器。
因此一致性哈希常用于分布式缓存如Redis。

#### 5.数组和链表的区别？太简单，略。

#### 6.栈和队列的区别？太简单，略。



## 智能指针
#### 0.智能指针有哪几种？
share/weak/unique/auto

#### 1.shareptr是不是线程安全的？
否，shareptr只通过原子操作保证计数是线程安全的，但多线程同时访问shareptr所管理的对象时依然会有并发问题，需要加锁。

#### 2.把uniqueptr移动到shareptr会发生什么？
uniqueptr的为空，不再拥有资源，shareptr创建一个新的控制块来管理资源。底层伪代码是：
```cpp
template<typename T>
std::shared_ptr<T>::shared_ptr(std::unique_ptr<T>&& uniquePtr) {
    if (uniquePtr) {
        // 接管资源
        this->ptr = uniquePtr.release();
        // 创建控制块
        this->controlBlock = new ControlBlock();
        this->controlBlock->refCount = 1;
    } else {
        this->ptr = nullptr;
        this->controlBlock = nullptr;
    }
}
```

#### 3.weak_ptr是为了解决？
为了解决shareptr的循环引用，比如类A声明了类B的shareptr，类B声明了类A的shareptr，这俩指针就永远不会被释放。
而weakptr的思想就是只观测而不增加引用计数，好比房产中介知道所有房地产的信息(通过lock()方法能安全访问shareptr)，但是不拥有房产。
因此weakptr也很适合用在观察者模式。

但要注意的是，weakptr不是真的不引用，它有一个弱引用计数。弱引用计数是为了计算有多少个weakptr在观察shareptr，当shareptr的引用计数归0时，weakptr并不会被释放。
只有当弱引用计数也归0时，控制块和weakptr才真的会被释放。这么设计是为了确保weakptr可以正确检测shareptr是否被正确释放。

#### 4.share_ptr的底层实现？回收原理？
```cpp
#include<iostream>

template <typename T>
class shared_ptr{

private:
	T* ptr;
	size_t* cnt;
	/*
	将引用计数减1，如果减后变为0
	说明没有其他实例引用该对象，于是释放占用的内存。
	*/
	void realse(){
		if(cnt && --(*cnt) == 0){
			delete ptr;
			delete cnt;
		}
	}
	
public:
	// 初始化
	explicit shared_ptr(T* _ptr = nullptr):ptr(_ptr),
		cnt(_ptr ? new size_t(1) : nullptr){
		
	}
	// 拷贝操作
	// 传入other，令this等于other并修改引用计数
	shared_ptr(const shared_ptr& other):ptr(other.ptr),cnt(other.cnt){
		if(cnt){
			++(*cnt);
		}
	}
	//赋值操作
	//shared_ptr& 表示返回的是一个引用，除了减少开销外
	//还可以支持a = b = c这样的操作
	shared_ptr& operator=(const shared_ptr& other){
		/*
		在赋值运算符重载函数中，通常是比较对象的地址是否相同
		常见的做法是将 other 的地址与 this 进行比较，即 this != &other
		如果写的是 *this != other，要重载 == 运算符
		*/
		if( this != &other){
			realse();
			ptr = other.ptr;
			cnt = other.cnt;
			if(cnt){
				++(*cnt);
			}
		}
		//这里this前加*号是this是指向当前实例的指针
		//解引用后才能返回实例(引用)
		return *this;
	}
	//析构函数
	~shared_ptr(){
		realse();
	}
	// 有时可能需要对指针进行算数运算，或其它需求
	// 总之get()用来支持返回原指针
	T* get() const {
		return ptr;
	}
	// 常规的解引用
	T* operator->() const {
		return *ptr;
	}
	T& operator*() const {
		return *ptr;
	}
	size_t getCnt() const {
		return cnt ? *cnt : 0;
	}
};
class Myclass{
public:
	Myclass(){
		
	}
	void doSomething(){
		
	}
};
int main(){
	shared_ptr<Myclass> ptrA(new Myclass());
	std::cout<< ptrA.getCnt() << '\n';
	shared_ptr<Myclass> ptrB;
	ptrB = ptrA;
	std::cout<< ptrA.getCnt() << '\n';
	std::cout<< ptrB.getCnt() << '\n';
}
```

以上是手写版，真正底层是维护一个
控制块(Control Block)，含引用计数/弱引用计数/删除器/指向对象的指针，回收是基于引用计数，引用计数为0时删除指向对象，但不删除控制块。建议使用shareptr时用make_shared，它将对象和控制块的内存分配合并为1次，但也导致了这俩内存绑定在一起，
弱引用计数为0时才会一起释放。

## 语法
#### 1.struct和class区别？底层是如何实现的？
最大的区别是class默认成员权限和继承方式是private的，而struct则是public的，其它几乎完全相同。
但struct是C语言的遗产，设计主要用于POD类型，没有复杂的封装和析构/构造函数等。

#### 2.虚函数的实现原理
虚函数表+虚函数指针。

虚函数指针存放在对象所在内存空间最开始的部分，指向虚函数表。当然如果继承自多个对象，在内存空间的布局上会按顺序依次排开：
基类A的虚函数指针，基类A的成员1，基类A的成员2...基类B的虚函数指针，基类B的成员1，基类B的成员2。

虚函数表则存储了该类所有虚函数的地址，如果派生类重写了虚函数，虚函数表会更新为派生类的函数地址。
同理，如果继承自多个对象，也会有多个虚函数表。

虚函数被诟病为效率低，但事实上真的计算起时间效率(不过多了几次间接寻址)和计算空间效率(多维护了几个指针)的话，如果继承关系不复杂，其实差不多。
最主要的开销是只能在动态运行时绑定，因此无法在编译阶段优化，并且多重继承时要维护很多的虚函数表，哪怕用不上，比如GUI库就是这种情况。

#### 3.构造/析构函数允许是虚函数吗？
构造函数不可以，最主要的原因是虚函数使用了虚函数表（vtable），在调用构造函数时，对象还没有完全创建和初始化，所以虚函数表可能尚未设置。
在构造函数中使用虚函数表会导致未定义的行为，也会被编译器禁止。
此外，虚函数是为了实现覆盖基类的成员函数，但每个类都有自己的构造函数，构造对象时编译器知道正在构造的是哪个类，因此会直接调用该类的构造函数。
不需要通过虚函数机制动态绑定。没必要用构造函数来实现多态。

但基类的析构函数一定要是虚函数，否则删除基类指针时，只会调用基类的析构函数，不会调用派生类的虚构函数，导致这部分资源无法被释放。

#### 4.构造和析构函数里throw会有什么问题？
构造函数里throw没问题，还可以帮助确认资源是否被正确初始化。
析构函数里throw有大问题，因为遇到异常时C++的处理机制是会栈展开，往上找能匹配的catch块，如果此时析构函数抛出异常，遇到两个异常会直接terminate，会导致资源无法被正确释放。


#### 5.如果有一个类在析构的时候可能throw，怎么设计能保证正确析构并释放内存？
最好最好还是不要在析构时throw，但可以暴露出接口，让用户显式调用，比如将可能抛出异常的代码从析构函数中移出，放到一个普通的成员函数中(如 close() 或 release())中。
或者用RAII模式，写一个资源管理类，将资源管理与对象本身分离，主对象的析构函数可以抛出异常，但不会影响资源释放。


#### 6.C++11/14新特性，你常用的有哪些？
auto/智能指针(配套的make_unique)/移动语义/unordered_map/optional

#### 7.讲一下左值和右值/移动语义/万能引用和完美转发？
左值是可以出现在等式左边和右边的值，有名字有内存地址的值，而右值是不是左值的值。
更具体的，只能出现在等式右边，短暂地存在，没有名字也没有内存地址的值，比如int x = 20中的20，比如函数的返回值。

右值的出现是为了支持移动语义/万能引用/完美转发。没错，这几点都可以串在一起讲。
cpp primer里说到，原本的拷贝构造函数都会先复制出一个temp对象，再将temp对象复制到需要的内存卡中，再将临时对象删除。
考虑到临时对象被删除了，如果能直接转让这个临时对象的所有权给要赋值的对象，不是更好吗？而这种不真正移动，只修改记录的方法就是移动语义。
要实现移动语义，需要让编译器知道什么时候需要复制，什么时候不需要。因此可以定义两个构造函数，一个是常规复制构造函数，使用const左值引用作为参数；
另一个是移动构造函数，使用右值引用作为参数。

万能引用指的是T&&,原理是引用折叠规则(&遇到左值返回左值，遇到右值返回左值，&&遇到什么返回什么)，所以可以保留参数的类型。
通常和forward结合使用，forward的原理是写了两个都声明为forward的函数，一个接受左值，一个接受右值，返回类型都为T&&:
```cpp
template<typename T>
T&& forward(typename std::remove_reference<T>::type& arg) noexcept {
    return static_cast<T&&>(arg);
}

template<typename T>
T&& forward(typename std::remove_reference<T>::type&& arg) noexcept {
    return static_cast<T&&>(arg);
}
```
有了万能引用后，就可以实现完美转发。有如下应用：
- 工厂函数用于创建对象，并可能需要将参数传递给对象的构造函数。完美转发可以确保参数以原始的值类别传递。
- 实现容器的插入、删除等操作时，可能需要将参数以原始的值类别传递给容器内部的函数。比如a.push_back(42)
- 多线程任务传递时需要将任务和参数传递给线程池，完美转发可以确保参数的值类别不变。


#### 8.讲一下纯虚函数和抽象类，虚函数和纯虚函数的的区别？
纯虚函数是一种在基类中声明但没有实现的虚函数。它的作用是定义了一种接口，这个接口需要由派生类来实现。（PS: C++ 中没有接口，纯虚函数可以提供类似的功能）。包含纯虚函数的类称为抽象类（Abstract Class），抽象类仅仅提供了一些接口，但是没有实现具体的功能。作用就是制定各种接口，通过派生类来实现不同的功能，从而实现代码的复用和可扩展性。

两者区别为：
- 虚函数有默认实现，纯虚没有默认实现，用=0来声明。
- 虚函数基类可以实例化，纯虚不行
- 派生类可选是否重写虚函数，纯虚则必须要实现

#### 9.讲讲拷贝构造函数和operator=()
拷贝构造函数用于初始化新对象，赋值运算符则用来赋值给已存在的对象。
赋值运算符需要自赋值检查，两者都需要特殊处理深拷贝与浅拷贝。

#### 10.memcpy和memmove区别
最大的区别在于处理内存重叠时行为不同，memcpy不处理内存重叠，因而性能更强。
memmove则能正确处理内存重叠,如果源区域和目标内存区域重叠，memmove会确保拷贝后的数据是正确的。


#### 11.内存屏障了解吗？
了解。多线程或多核环境中，编译器和处理器可能会对内存操作进行重排序以提高性能。然而，这种重排序可能出问题。
比如
```cpp
int x = 0;
bool ready = false;

// 线程 1
void thread1() {
    x = 42;         // 写操作
    ready = true;   // 写操作
}

// 线程 2
void thread2() {
    if (ready) {    // 读操作
        assert(x == 42);  // 读操作
    }
}
```
没有内存屏障，编译器和处理器可能会对 thread1 中的两个写操作进行重排序，导致 thread2 看到 ready == true 但 x != 42 的情况。
内存屏障主要分为写屏障/读屏障/全屏障，可以用硬件或者软件来实现，C++11中则是std::atomic_thread_fence。

#### 12.值传参和引用传参的区别？效率有区别吗？
值传参是pass by value，有拷贝开销，不会影响实参；引用传参传引用，没有拷贝开销，但会影响实参。
效率方面因为没有拷贝，引用传参的效率远高于值传参。

#### 13.void* 指针能否做算数运算，为什么？有什么作用？
不能，算数运算的本质是移动类型对应的size，void连类型都没有，怎么移动。
void* 可以指向任意类型的数据，常用在泛型编程，比如C标准库中qsort和bsearch就是用void* 指针。
动态内存管理(malloc)时用的也是void*，因为不知道用户将会分配成什么类型的内存。同理，接口设计时如果
参数不定类型，也可以传void* 指针进去。

#### 14.const可以修饰全局函数吗？const全局变量在.data段还是.bss段？const局部变量存在哪？有没有办法修改const修饰的变量？const T &可以接受右值吗？
- const不能修饰全局函数，const 关键字只能用于修饰类的成员函数，表示该函数不会修改类的成员变量。全局函数没有类的上下文，因此不能用 const 修饰。
- 全局变量存储位置取决于是否被初始化。已初始化的const全局变量存储在.data段(只读数据段)，未初始化的全局变量存储在.bss段(未初始化数据段)。
- const局部变量存储在栈中，只是值不能被修改。
- 可以用mutable。
- const T &可以接受右值，因为const承诺不会修改对象，还可以延长其生命周期。而非 const 引用（如 T&）不能绑定到右值，因为右值是临时对象，非 const 引用可能会修改它，导致未定义行为。

#### 15.常成员函数的作用？
- 常成员函数的主要作用是保证该函数不会修改类的成员变量，常用于只读函数如get()或者打印对象状态
- 可以支持const对象调用

#### 16.空类大小，继承空基类的子类大小，继承空虚基类的子类大小？
- 空类大小为1字节
- 如果子类没有新增成员变量或虚函数，编译器可能会进行空基类优化（Empty Base Optimization, EBO）。在 EBO 优化下，子类的大小为 1 字节。如果没有 EBO 优化，子类的大小可能为 1 字节（基类） + 1 字节（子类） = 2 字节。
- 8字节，因为要存虚表指针。当然新增了成员变量或者虚函数，子类大小也会相应增加。

#### 17.new和malloc区别？C++的内存分布模型？
前者是c++运算符，后者是库函数。
- 分配内存位置：new在自由存储区，并且会调用对象的构造函数来初始化对象；malloc在堆上，只分配内存。
- 返回值：new为完整类型指针，malloc为void*
- 大小：new会自动计算，malloc必须自己指定
- 内存扩充：new没法直观处理，realloc可以简单完成
- 互相调用：new可以调用malloc，也可以不调用，毕竟new有好多种，可以连内存都不分配。但显然malloc不可以调用new。
  

#### 18.讲一下assert和static_assert
assert是断言，如果不满足条件就会中止，常用于开发环境。
static_assert是编译时如果不满足会直接中止，用于检查编译时的常量表达式，例如模板参数、类型大小等。
assert不会在编译时中止，用于检查运行时逻辑错误。

#### 19.不借助库函数如何判断大小端？什么时候需要注意大小端？
```cpp
bool isLittleEndian() {
    int num = 1;  // 0x00000001
    char* ptr = reinterpret_cast<char*>(&num);//reinterpret_cast是进行低级别的强制转换
    return *ptr == 1;  // 在这里其实是未定义行为，相当于输出第一个字节
    //而如果第一个字节是 1，则是小端
}
```
原理是利用char和int占用的字节差。

#### 20.多态实现和原理？
多态分为动态多态（基于虚函数的动态绑定）和静态多态（模板/函数重载），虚函数上面见过了，提一下后者。
- 模板：相当于给编译器提供了一个蓝图，编译器会拿着这个模板去生成对应的代码
```cpp
template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
int main() {
    std::cout << max(10, 20) << std::endl;       // 输出 20
    std::cout << max(3.14, 2.71) << std::endl;   // 输出 3.14
    return 0;
}
```
- 函数重载：函数重载是指同名，但参数列表(顺序/类型/参数类型)不同。
以下就是一个复杂的函数重载。
```cpp
template<typename T>
T&& forward(typename std::remove_reference<T>::type& arg) noexcept {
    return static_cast<T&&>(arg);
}

template<typename T>
T&& forward(typename std::remove_reference<T>::type&& arg) noexcept {
    return static_cast<T&&>(arg);
}
```

#### 21.空类会自动生成什么函数？
默认构造函数(只分配内存)/默认析构函数(什么也不做)/默认拷贝构造函数/默认拷贝赋值运算符/
默认移动构造函数/默认移动赋值运算符/默认的new delete &运算符。
这是因为哪怕类是空的，也要保证它能被正确构造/赋值/移动/销毁等。

#### 22.介绍一下移动构造？
移动构造上面说过了，本质上是原本的拷贝构造太慢，所以引入了右值引用实现移动构造。
原理是通过右值引用绑定到临时对象或即将销毁的对象，然后“窃取”其资源。具体步骤如下：

窃取资源：将新对象的指针指向原对象的资源。
置空原对象：将原对象的指针置空，避免资源被重复释放。
```cpp
//例子一：
MyClass(MyClass&& other) noexcept {
        data = other.data;  // 窃取资源
        other.data = nullptr;  // 将原对象的资源置空
}
//例子二：
```


#### 23.栈区和堆区区别？在栈上新建对象和在堆上新建对象区别？
以下讨论的是程序内存里的栈区和堆区
- 内存管理：栈由编译器管理，堆区由程序员手动管理
- 生命周期：随作用域结束释放；需要显式释放
- 分配：移动栈指针，快速；查找合适的内存块，较慢
- 大小：较小，以MB为单位；较大，受系统内存限制
- 适用：局部变量，函数调用栈；动态分配的大型对象，长期存在的对象。

新建对象的区别：
```cpp
class MyClass {
public:
    MyClass() { std::cout << "Constructed\n"; }
    ~MyClass() { std::cout << "Destructed\n"; }
};

int main() {
    MyClass* obj = new MyClass;  // 在堆上新建对象
    delete obj;                 // 显式释放对象
    return 0;
}

//====我是分割线====
class MyClass {
public:
    MyClass() { std::cout << "Constructed\n"; }
    ~MyClass() { std::cout << "Destructed\n"; }
};

int main() {
    MyClass obj;  // 在栈上新建对象
    return 0;     // obj 自动销毁
}
```

内存空间布局为：
+---------------------+
|       栈区          |  （高地址，向下增长）
+---------------------+
|      自由映射区      |
+---------------------+
|       堆区          |  （低地址，向上增长）
+---------------------+
|     全局/静态区      |
+---------------------+
|      代码区         |
+---------------------+


#### 24.define/const/constexpr区别和应用场景
区别：
- define，宏定义，在编译前完成，无作用域全局有效
- const，用来定义常量，运行时确定，有类型和作用域
- constexpr，用来定义编译时计算的量，编译时确定，提高运行时性能，有类型和作用域

#### 25.lambda的应用


#### 26.virtual和override的区别和应用
override用来强调对虚函数的重写，使得代码的可读性更高，但其实可以不用。

#### 27.sizeof 和 strlen 的区别
strlen 是头文件 cstring 中的函数，而 sizeof 是 C++ 中的运算符
sizeof 返回类型的字节，strlen计算字符串的长度(且不包括'/0')

#### 28.*int const a和const *int a有什么区别
前者表示常量指针，即指针本身不能被修改，但指向的值可以被修改；
后者表示指向常量整数的指针。
(巧记方式:就近原则，const接近指针a，所以修饰指针，const接近int，修饰值本身。)

#### 29.scanf和cin有什么区别，为什么scanf比较快
cin类型安全，自动推导类型，无需手动指定格式符，又因为要实现上面这些功能，所以涉及到更多的抽象和封装，自然比较慢。scanf则直接与底层IO交互，要手动指定格式符。

此外影响比较大的是缓冲机制，cin使用标准库的流缓冲机制，默认与stdio同步，这会带来额外的开销。



#### 30.几种类型转换之间的区别
- static_cast <new_type> (expression),用于基本类型/指针/引用类型之间的转换，和C语言中做强制类转换基本等价
- dynamic_cast <new_type> (expression)，常用于将基类指针或引用转换为派生类指针或引用，dynamic_cast可以确保类型兼容性。dynamic_cast只有在基类存在虚函数(虚函数表)的情况下才有可能将基类指针转化为子类，否则返回异常。其依赖运行时信息(RTTI)来判断类型是否正确。
- const_cast <new_type> (expression),其中new_type必须是一个指针/引用，用来抹去const属性，比如修改const对象，或者用于const对象调用非const成员函数。
- reinterpret_cast <new_type> (expression)，用于在不同类型中进行低级别转换。仅仅是重新解释底层比特（也就是对指针所指针的那片比特位换个类型做解释），而不进行任何类型检查。
  
#### 31.内联函数知道吗？有什么好处？
内联函数在编译时会被直接展开，而不是通过函数调用的方式执行，这样就避免了栈帧的创建和销毁/参数传递/返回地址保存等操作。
适用于小型且频繁调用的函数。但inline只是对编译器的建议，编译器可能会忽略内联请求。

# OS
#### 1.消息队列有了解过吗？如何保证信息不丢失？如何保证一致性？

#### 2.fork()的具体过程？

#### 3.fork()都会返回吗？

#### 4.linux命令行输入命令后的执行过程？

#### 5.CAS操作了解吗？

#### 6.int和uint和浮点数的二进制表示，每一位的含义？

#### 7.进程和线程的区别，相关系统调用

8.锁有哪些种类？互斥锁和自旋锁的区别与具体应用？能不加锁吗？
-
-
- 能不加锁，但更为复杂。比如TBB和boost就提供了基于原子操作或者细粒度实现的容器。

#### 9.用户态内存分为哪些区域？

#### 10.程序运行经历的阶段？

#### 11.如何保证一个类是线程安全的？

#### 12.i++操作是线程安全的吗？

#### 13.生产消费者模型中锁是如何实现的？

#### 14.进程间通信方式？

#### 15.进程间共享变量怎么做？

#### 16.为什么要用虚拟内存？为什么要分段和分页？

#### 17.什么是内核态，什么是用户态

#### 18.异常和中断的区别？

# 数据库
#### 1.什么时候该建立索引？什么时候不该建立索引？如何建立索引？

#### 2.查询索引一定更快吗？分析下列情况怎么使用索引会更快？

#### 3.数据库内核是怎么决定是否使用索引查询以及该用哪个索引查询？如何sampling，怎么计算查询成本和
生成执行计划？

#### 4.如何让索引尽可能加速查询操作？

#### 5.回表是什么？如何减少回表操作？

#### 6.如果数据库的io很大，有哪些可能性，该如何排查并定位原因，该如何优化？

#### 7.数据库还有哪些性能指标？

#### 8.为什么主键要用自增id？

#### 9.覆盖索引了解吗，具体怎么用？

#### 10.为什么用B+树不用B树？为什么B+树胖且矮？如果把内容存在内存上，用B树会不会快一点？

#### 11.B+树和B树的时间复杂度有什么区别，有的话差多少？

#### 12.(a1,a2,a3)查找(a2,a3)会找到a1吗(最左前缀原则)？

#### 13.怎么保证数据库和redis一致性？

#### 14.讲一下一条SQL语句查询的全过程

#### 15.讲一下隔离级别？

#### 16.如何解决脏读/不可重读/幻读？能不加锁吗？

#### 17.知道MVCC吗？

#### 18.redo log和undo log有什么区别？


# 计网
## TCP
#### 1.TCP三次握手过程/四次挥手过程？为什么是三次，为什么是四次？多一次少一次不行吗？

#### 2.syn序列号是怎么确定并发送的？

#### 3.为什么ack回应的序列号是x+1？

#### 4.简述DDos攻击，该如何防治？

#### 5.RST有什么具体作用？

#### 6.MTU是什么？

#### 7.TIME_WAIT有什么用？

#### 8.比较TCP和UDP

#### 9.TCP为什么会粘包(Nagle)算法和解决方法？

#### 10.怎么设计一个可靠且报文有序的UDP协议？

#### 11.讲一下TCP的滑动窗口机制，滑动窗口大小如何确定？

#### 12.全连接队列与半连接队列了解吗？

#### 13.如果出现很多次close_wait怎么解决？close_wait和time_wait分别在哪个阶段？

#### 14.TCP建立连接个数可以超过端口号个数吗？如何确定唯一的TCP连接？

#### 15.流量控制与拥塞控制区别？

#### 16.输入一个URL，计算机会发生什么？

## HTTP

#### 1.http请求由哪部分构成？

#### 2.常见的请求头有什么？

#### 3.get和post的区别？

#### 4.HTTP用TCP还是UDP？

#### 5.常见状态码

#### 6.是长连接还是短连接，如何用UDP实现

#### 7.使用HTTP从服务器获取数据，数据有长有段，如何接受？

#### 8.HTTP为什么要用非对称加密和对称加密？为什么不只用一个？

#### 9.知道http有几个版本吗，2和3有什么区别

## 网络安全
#### 1.对称加密与非对称加密过程？

#### 2.HTTPS怎么保证安全通信？


## 其它协议
#### 1.知道ICMP吗？

#### 2.7层，5层，4层协议？每层的常见协议？

#### 3.cookie和session的区别？

## 服务器底层
#### 1.epoll和select和poll有什么区别

#### 2.什么时候用水平触发，什么时候用边缘触发？

#### 3.一个TCP句柄什么情况下会有可读事件？

#### 4.TCP的connect发送了什么报文?

#### 5.UDP的句柄能执行connect吗？

# 中间件
#### 1.zookeeper了解吗？

#### 2.MySQL/Redis/Kafka等在高性能，高可用，高并发方面有什么设计？
Redis有哨兵集群和切片集群。

#### 3.Redis的缓存三姐妹(缓存穿透/缓存击穿/缓存雪崩)？手动更新完数据库，导致缓存失效了，大量的数据全打在数据库上怎么处理？

#### 4.etcd的原理？

#### 5.redis和mysql区别(?)

#### 6.MySQL底层使用的数据结构？


# 设计模式
#### 1.单例模式怎么实现？

#### 2.怎么实现一个线程一个单例？

# Linux
#### 1.查看进程系列命令:
- ps-aux第二列是什么
- ps-aux和ps -elf的区别

# 脑筋急转弯
#### 1.10个红球和10个白球放俩盒子里，怎么分配使得从这俩盒子中摸一个球是红球的概率最高？

#### 2.25匹马，5个跑道，最少需要多少次比赛选出最快top3？

#### 3. 有1000瓶水，只有1瓶有毒，有无限老鼠，老鼠可以喝任意瓶。毒药会在24小时后发作，请在一天内
用最少老鼠找出哪瓶有毒？


# 场景题
#### 1.1s内有大量用户访问，怎么缓解服务器压力？

#### 2.内存泄漏怎么解决？

#### 3.如果有一个错误的提交怎么把它退回到正确的，包括本地和远端都要回退？

#### 4.gdb在程序运行时如何调试？

#### 5.设计一个应用层使用TCP应该注意哪些？


# 高频lc
- 链表反转
- 链表归并
- LRU缓存
- k个链表归并
- k个一组反转链表且空间O(1)时间O(n)
- 重排链表
- 括号匹配
- 寻找avl第k大的数
- 三数之和
- 未出现的最小正整数且空间O(1)时间O(n)
- 判断字符串s是否为字符串t首尾连接构成的环的一部分
- 找出数组中第k大的数
- 主站1081
