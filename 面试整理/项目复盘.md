2025/09/19 收到字节系-懂车帝面邀，考虑到准备时间有限，故在3.5天内针对实习、项目、针对性八股进行重点突击 + 刷30道hot lc 找回手感。
2025/10/11 收到字节-Tiktok音乐方向后台面邀，继续完成上次未竟的整理。

 

## 实习：

经历描述：期间独立主 R 小型需求，完成方案设计、技术评审、代码开发、自测联调、对接产运 QA、上线在内的全链路流程，有 DDD 分层架构与 CleanCode 意识。参与稳定性治理工作，完成日志治理解决频繁 gc/重复告警/有效日志不足问题；完成 i18n 多时区治理支持出海开国业务；完成 Device 服务拆分实现领域闭环与职责分离，负责Job 任务的灰度改造/Stage 环境测试/切流打点观察。有独立分析告警指标、排查问题并给出可靠结论的能力。
可能的问点：

#### 你对DDD的了解是？界限上下文怎么划分？
传统的MVC架构在开发的后期有天然劣势。比如一个订单服务，可能包含订单接口、评价接口、支付接口等，order表里存储了所有字段。维护代码时可能只想改下评价相关功能，却影响创单核心路径。根本原因是划分出来的模块高耦合，实现层面所有代码都写在一个serverimpl里。

传统的重构方式可以抽出单独的类和通用方法，但很难有业务层面的意义，只是为了代码好看。这导致新同学开发时难以理解，而DDD可以很好解决这个问题。

我对DDD的理解：本质上是对业务进行自然语义上的拆解，拆解成多个领域对象后将相关行为和数据注入，把业务逻辑和业务状态聚合在特定领域内，使其"充血"。

比如做抽奖平台时，抽奖平台是一整个领域。而用户划分为运营和消费者，这样能划分出M端和C端两个限界上下文。

接下来以C端为例，分析产品的需求。抽象活动有如下限制：
次数限制、时间限制、一个活动包含多个奖品、奖品本身有配置（库存、概率、被同一个用户获得的次数）、用户有新老和地域之分、活动本身有风控限制。

提取上述概念形成以下几个限界上下文：抽奖（核心子域，包含了用户和奖池，其中奖池对象的行为是为一组用户设置多个奖品并输出抽奖结果。奖品配置、概率、用户划分都在这个子域里维护），活动准入（维护次数和时间限制），库存（维护奖品核销，且本身具有通用性，可以独立出来），风控（这块显然是独立的）。

划分界限上下文我的理解是整个DDD设计里最难也最核心的，要根据语义去把能高度关联的需求在聚合一起，同时理清各个上下文之间的关系。比如这里抽奖要依赖库存、活动准入、风控，但库存和活动准入本身相对独立。

这些做完才是对代码层面的细化，如将领域行为封装到领域对象中，将资源管理行为封装到资源库中，将外部上下文的交互行为封装到防腐层中，承接新需求时就是对各个领域进行编排。



#### CleanCode意识在哪里体现？
这个有标准的规范，比如很出名的阿里巴巴Java开发指南，我自己的个人习惯是：每个方法尽量不要超过50行；变量名和方法名必须让读的人知道我要干什么；不写魔数；注释足够清晰；一个参数不会到处透传到底，会产生很多冗余，宁可多写几层做好PO/VO/DTO的转换；缩进和换行整个团队用同一套rules；重复的代码尽可能抽成通用方法；少写if-else嵌套来减少圈复杂度；承接需求时不做定制化，尽量做成通用接口。


### 怎么解决频繁gc的？
这个问题最开始是压测时发现gc问题频繁，查看堆对象有很多string、byte这类日志相关对象，初步考虑日志问题引起的gc。第二次压测时把日志打印取消，就没gc了，所以判定为日志打印引起。

解决时最开始老板希望我对过大的日志量做个抽样，比如每1%才打印一次。我做方案调研时发现日志抽样是个相对低频的技术方案，且抽样要考虑到分级别抽样，info级别可以不全大，error肯定要全打。随机也有随机的讲究，是对一个traceId取模打印呢，还是核心链路和非核心链路的随机数是不是也要不同。在实现层面，手写一个过滤工具类再手动加上显然是不现实的，稍微好一点的方式是切面编程aop，再加注解，但可能增加性能负担，此消彼长下效果如何有点存疑。

卡住时突然想到不一定要做抽样，本质上可能是个伪需求，既然日志打印很多，那就看看多在哪里，是否都有必要，抽样不如删掉。为什么不删掉？登机器一看发现几分钟能打500M，其中有一部分是debug日志打印线程情况，还有一部分是打印大JSON对象，但这些根本没法看，对研发排查问题没什么帮助。最后去掉并上线，gc就下来了。



### 讲一下gc原理
gc是对垃圾内存的自动回收，之前写cpp时要用malloc和free手动申请内存和释放，否则会造成内存泄漏。Java有一套完整的gc机制，程序员就不用手动管理内存。

判断一个内存是否还在用有一种朴素的思路：维护对该内存的计数引用，如果为0则废弃。但这样1会带来额外开销，2无法解决循环引用的问题。所以java里用的是可达性分析算法。

它的基本思想是从被称为GC Roots的根对象触发，遍历对象引用图，不被遍历到的就算可以被回收的。GC Roots有很多，比如常量或静态属性引用的对象，基本数据类型对应的class对象，系统类加载器等。这些对象肯定是活着的。

我学gc时有一个疑问：万一不可达的对象其实还有用，只是暂时不可达，真的可以安全回收吗？

后面想明白了只能通过引用访问对象，没有引用就无法访问，没有意义保留。至于不可达但还有用这个问题，场景很少，除非是用反射去强行访问，这个行为就是未定义的了。

至于gc怎么回收，朴素的思路是打标记-清除。由于清除会产生大量不连续碎片，所以又搞了复制算法，内存只用一半，清理时把还活着的内存统统挪到另一半，再一口气清掉刚用过的这一半。引起的另一个问题是内存变成一半了，且复制也有开销，对于一些存活率很高，需要被回收的数目少的对象，每次把一大个对象搬来搬去很麻烦，针对这个问题提出了标记-整理方法，让所有存活对象通过指针向同一方向移动，均摊下来会减少复制开销。

现代虚拟机采用分代收集算法来gc，这种算法是上面内容的结合，根据对象的生命周期不同将内存划分为几块，每块采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。


### gc还可能是什么情况导致？



### 日志打印不当可能造成哪些问题？


### Job任务的灰度放量具体怎么放，灰度是怎么实现的，切流又是怎么实现的？
对http流量的请求头里塞入版本；根据地域进行灰度；转发的时候转发到对应的灰度实例或者原有的实例。
具体怎么灰度跟中间件有关系，网关请求类就按配置路由规则去灰度；服务发现类按实例分组；异步消息队列类的按灰度消费组灰度。

### 服务发现、注册类中间件原理？配置中心原理？
注册中心就像服务的通讯录。服务上线时会向注册中心注册自己的元信息(IP、端口、服务名)，通过SDK或者http向服务中心发起注册请求。注册中心收到后会把信息写到本地注册表并持久化。接下来provide每隔一段时间主动发送心跳包，部分注册中心也会主动进行健康检查。服务下线时正常会调用相关端口，不正常的话探测失败到一定次数就把它下线。
CAP理论中C是consistency一致性，A是avaliable可用性，P是partition tolerance分区容忍性，对于分布式系统来说P是必须的，那就只能在C和A之间取舍了。
CP的经典例子是zookeeper，它有个ZAB协议来确保一致性。有个leader专门负责写请求，follower处理读请求，转发写请求，同步数据。虽然保证了强一致性，但lead挂了且在选举期间，注册中心就不可用了。
AP的经典例子是nacos，优先保证可用性。注册中心挂了客户端也有本地缓存，最后能一致就行。nacos的AP是通过服务唯一对应主节点，请求会被路由到该节点。写入内存并落库后就会返回成功，再异步同步给其它节点。

#### 介绍一下zookeeper和ZAB协议
zookeeper是一个分布式协调服务系统，可以用来统一配置，服务注册，集群管理。
写时lead会发起请求，过半数节点同意后会提交该事务，所有节点都执行。从任意节点读取到的都是最终数据。
宕机时的选举机制是互相投票，节点收到她人投票后如果对方的zxid或者myid更大，就改投对方。不断交换选票直到出现lead。期间注册中心无法使用。
ZAB协议需要奇数个节点是因为同样容错能力下，节点数更少，协商更快。最重要的是确保多数派只会有一个，能防止脑裂，或者怎样都选不出lead的情况。


#### 负载均衡算法
nginx用的是经典的roundrobin，指针递增，对总数取模。支持加权和健康检查，比如一定时间内失败次数超过一定阈值标记为不可用，暂时移出轮询队列，后面会尝试再将请求分配给实例。不绑定会话session，同一客户端请求会被分配到多个实例。
dubbo的负载均衡会强一点，因为是阿里的rpc框架，对负载均衡要求高点。它的轮询是客户端负载均衡，消费者本地通过注册中心同步提供者列表，并独立轮询。支持权重动态配置（消费者本地可直接同步）和平滑加权轮询（基础权重和当前权重的设置有助于小权重实例被选中，避免请求全部集中打到大权重实例）。健康检查是基于主动心跳和熔断机制。

### 既然提到了dubbo，讲一下rpc框架通常都是怎么设计的，解决什么问题，怎么实现跨语言通信？
调用远程服务时能像调用本地一样。过程：
1.服务消费方(client)调用以本地调用方式调用服务;
2.client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体;
3.client stub找到服务地址，并将消息发送到服务端;
4.server stub收到消息后进行解码;
5.server stub根据解码结果调用本地的服务;
6.本地服务执行并将结果返回给server stub;
7.server stub将返回结果打包成消息并发送至消费方;
8.client stub接收到消息，并进行解码;
9.服务消费方得到最终结果。
其中代理可以通过动态代理实现，编码和解码的部分可用的协议有很多，最常见的JSON,protocolbuffer(用二进制编码，自带编译器，速度快，跨语言)。
网络层的实现看框架，grpc用的是http2.0（自带单TCP多路复用，消息头压缩这些特性，速度更快）。

### 告警后的解决思路？主要看哪些指标？排查过什么问题觉得比较有成就感？
比如说监控发现mysql cpu内存占用较高，连接池较满，有哪些原因导致的，可能有哪些排查方向？
注册中心干什么的？
分布式配置系统的原理怎么实现？
 
项目：
讲一下事件驱动模式？
一个请求打过来，在每个组件之间流转的流程？
智能指针优化什么了？
redis相关：
redis整个底层实现了解吗？解决什么问题的，原理？
常用的集群结构有哪些？
redis cluster如何找到对应节点？
跳跃表原理，范围查找；比较哈希表，zset，跳跃表？
如何实现分布式锁？
redis里的expire怎么实现，你来写怎么写？
消息队列相关：
partion和消费者的数量关系；
如何保证不丢消息；
下游怎么保证幂等；
rabiitMQ在这个项目里怎么用的？
有没有对自己的系统做过测试？
 
针对性八股：
408复习（见：）
多线程相关：
线程同步和线程安全一个问题吗？
三个线程循环打印abc，abc，abc？
三线程轮流打印1-1000；
synchronise怎么做到一个操作，怎么保证线程同时赋给自己，又赋给主内存？
MySQL:
索引的数据结构为什么不用其它的要用B+树
索引机制；
索引失效；比如说我有一个联合索引abc，查询是select from 表 where b> And a= 会用到索引吗，那a = 1 b >2 c=3呢；
慢查询；
表空洞怎么处理；
Binlog怎么看；
mvcc隔离等级，重复读，读提交，快照读；
delete是否加行锁
page是什么，页是什么；
Java相关：
spring；
ioc；
aop；
单例模式实现；
